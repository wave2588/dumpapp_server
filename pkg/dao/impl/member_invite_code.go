// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package impl

import (
	"context"
	"database/sql"
	"fmt"

	"dumpapp_server/pkg/common/clients"
	"dumpapp_server/pkg/common/errors"
	"dumpapp_server/pkg/dao/models"
	mysqlDriver "github.com/go-sql-driver/mysql"
	pkgErr "github.com/pkg/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type MemberInviteCodeDAO struct {
	mysqlPool *sql.DB
}

var DefaultMemberInviteCodeDAO *MemberInviteCodeDAO

func init() {
	DefaultMemberInviteCodeDAO = NewMemberInviteCodeDAO()
}

func NewMemberInviteCodeDAO() *MemberInviteCodeDAO {
	d := &MemberInviteCodeDAO{
		mysqlPool: clients.MySQLConnectionsPool,
	}
	return d
}

func (d *MemberInviteCodeDAO) Insert(ctx context.Context, data *models.MemberInviteCode) error {
	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}

	err := data.Insert(ctx, exec, boil.Infer())
	if err != nil {
		if mysqlError, ok := pkgErr.Cause(err).(*mysqlDriver.MySQLError); !(ok && mysqlError.Number == 1062) {
			return pkgErr.WithStack(err)
		}
	}
	return nil
}

func (d *MemberInviteCodeDAO) Update(ctx context.Context, data *models.MemberInviteCode) error {
	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}
	_, err := data.Update(ctx, exec, boil.Infer())
	return pkgErr.WithStack(err)
}

func (d *MemberInviteCodeDAO) Delete(ctx context.Context, id int64) error {
	qs := []qm.QueryMod{
		models.MemberInviteCodeWhere.ID.EQ(id),
	}

	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}
	_, err := models.MemberInviteCodes(qs...).DeleteAll(ctx, exec)
	if err != nil {
		return pkgErr.WithStack(err)
	}
	return nil
}

func (d *MemberInviteCodeDAO) Get(ctx context.Context, id int64) (*models.MemberInviteCode, error) {
	result, err := d.BatchGet(ctx, []int64{id})
	if err != nil {
		return nil, err
	}
	if v, ok := result[id]; !ok {
		return nil, pkgErr.Wrapf(errors.ErrNotFound, "table=member_invite_code, id=%d", id)
	} else {
		return v, nil
	}
}

// BatchGet retrieves multiple records by primary key from db.
func (d *MemberInviteCodeDAO) BatchGet(ctx context.Context, ids []int64) (map[int64]*models.MemberInviteCode, error) {
	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}
	datas, err := models.MemberInviteCodes(models.MemberInviteCodeWhere.ID.IN(ids)).All(ctx, exec)
	if err != nil {
		return nil, pkgErr.WithStack(err)
	}

	result := make(map[int64]*models.MemberInviteCode)
	for _, c := range datas {
		result[c.ID] = c
	}

	return result, nil
}

// 后台和脚本使用：倒序列出所有
func (d *MemberInviteCodeDAO) ListIDs(ctx context.Context, offset, limit int, filters []qm.QueryMod, orderBys []string) ([]int64, error) {
	if offset < 0 || limit <= 0 || limit > 10000 {
		return nil, pkgErr.Errorf("invalid offset or limit")
	}
	qs := []qm.QueryMod{qm.Select(models.MemberInviteCodeColumns.ID)}
	qs = append(qs, filters...)

	if len(orderBys) > 0 {
		orderBys = append(orderBys, "id desc")
		for _, orderBy := range orderBys {
			qs = append(qs, qm.OrderBy(orderBy))
		}
	} else {
		qs = append(qs, qm.OrderBy("created_at DESC, id DESC"))
	}

	if offset >= 0 && limit >= 0 {
		qs = append(qs, qm.Offset(offset), qm.Limit(limit))
	}

	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}

	datas, err := models.MemberInviteCodes(qs...).All(ctx, exec)
	if err != nil {
		return nil, pkgErr.Wrap(err, fmt.Sprintf("table=member_invite_code offset=%d limit=%d filters=%v", offset, limit, filters))
	}

	result := make([]int64, 0)
	for _, c := range datas {
		result = append(result, c.ID)
	}
	return result, nil
}

func (d *MemberInviteCodeDAO) Count(ctx context.Context, filters []qm.QueryMod) (int64, error) {
	qs := []qm.QueryMod{qm.Select(models.MemberInviteCodeColumns.ID)}
	qs = append(qs, filters...)

	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}

	return models.MemberInviteCodes(qs...).Count(ctx, exec)
}

// GetByCode retrieves a single record by uniq key code from db.
func (d *MemberInviteCodeDAO) GetByCode(ctx context.Context, code string) (*models.MemberInviteCode, error) {
	memberInviteCodeObj := &models.MemberInviteCode{}

	sel := "*"
	query := fmt.Sprintf(
		"select %s from `member_invite_code` where `code`=?", sel,
	)

	q := queries.Raw(query, code)

	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}

	err := q.Bind(ctx, exec, memberInviteCodeObj)
	if err != nil {
		if pkgErr.Cause(err) == sql.ErrNoRows {
			return nil, pkgErr.Wrapf(errors.ErrNotFound, "table=member_invite_code, query=%s, args=code :%v", query, code)
		}
		return nil, pkgErr.Wrap(err, "dao: unable to select from member_invite_code")
	}

	return memberInviteCodeObj, nil
}

// BatchGetByCode retrieves multiple records by uniq key code from db.
func (d *MemberInviteCodeDAO) BatchGetByCode(ctx context.Context, codes []string) (map[string]*models.MemberInviteCode, error) {
	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}
	datas, err := models.MemberInviteCodes(models.MemberInviteCodeWhere.Code.IN(codes)).All(ctx, exec)
	if err != nil {
		return nil, pkgErr.WithStack(err)
	}

	result := make(map[string]*models.MemberInviteCode)
	for _, c := range datas {
		result[c.Code] = c
	}

	return result, nil
}

// GetByMemberID retrieves a single record by uniq key memberID from db.
func (d *MemberInviteCodeDAO) GetByMemberID(ctx context.Context, memberID int64) (*models.MemberInviteCode, error) {
	memberInviteCodeObj := &models.MemberInviteCode{}

	sel := "*"
	query := fmt.Sprintf(
		"select %s from `member_invite_code` where `member_id`=?", sel,
	)

	q := queries.Raw(query, memberID)

	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}

	err := q.Bind(ctx, exec, memberInviteCodeObj)
	if err != nil {
		if pkgErr.Cause(err) == sql.ErrNoRows {
			return nil, pkgErr.Wrapf(errors.ErrNotFound, "table=member_invite_code, query=%s, args=memberID :%v", query, memberID)
		}
		return nil, pkgErr.Wrap(err, "dao: unable to select from member_invite_code")
	}

	return memberInviteCodeObj, nil
}

// BatchGetByMemberID retrieves multiple records by uniq key memberID from db.
func (d *MemberInviteCodeDAO) BatchGetByMemberID(ctx context.Context, memberIDs []int64) (map[int64]*models.MemberInviteCode, error) {
	var exec boil.ContextExecutor
	txn := ctx.Value("txn")
	if txn == nil {
		exec = d.mysqlPool
	} else {
		exec = txn.(*sql.Tx)
	}
	datas, err := models.MemberInviteCodes(models.MemberInviteCodeWhere.MemberID.IN(memberIDs)).All(ctx, exec)
	if err != nil {
		return nil, pkgErr.WithStack(err)
	}

	result := make(map[int64]*models.MemberInviteCode)
	for _, c := range datas {
		result[c.MemberID] = c
	}

	return result, nil
}
