// Code generated by "enumer -type=DispenseCountRecordType -json -sql -transform=snake -trimprefix=DispenseCountRecordType"; DO NOT EDIT.

package enum

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

const _DispenseCountRecordTypeName = "payinstall_sign_ipaadmin_presentedadmin_deleted"

var _DispenseCountRecordTypeIndex = [...]uint8{0, 3, 19, 34, 47}

const _DispenseCountRecordTypeLowerName = "payinstall_sign_ipaadmin_presentedadmin_deleted"

func (i DispenseCountRecordType) String() string {
	i -= 1
	if i < 0 || i >= DispenseCountRecordType(len(_DispenseCountRecordTypeIndex)-1) {
		return fmt.Sprintf("DispenseCountRecordType(%d)", i+1)
	}
	return _DispenseCountRecordTypeName[_DispenseCountRecordTypeIndex[i]:_DispenseCountRecordTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DispenseCountRecordTypeNoOp() {
	var x [1]struct{}
	_ = x[DispenseCountRecordTypePay-(1)]
	_ = x[DispenseCountRecordTypeInstallSignIpa-(2)]
	_ = x[DispenseCountRecordTypeAdminPresented-(3)]
	_ = x[DispenseCountRecordTypeAdminDeleted-(4)]
}

var _DispenseCountRecordTypeValues = []DispenseCountRecordType{DispenseCountRecordTypePay, DispenseCountRecordTypeInstallSignIpa, DispenseCountRecordTypeAdminPresented, DispenseCountRecordTypeAdminDeleted}

var _DispenseCountRecordTypeNameToValueMap = map[string]DispenseCountRecordType{
	_DispenseCountRecordTypeName[0:3]:        DispenseCountRecordTypePay,
	_DispenseCountRecordTypeLowerName[0:3]:   DispenseCountRecordTypePay,
	_DispenseCountRecordTypeName[3:19]:       DispenseCountRecordTypeInstallSignIpa,
	_DispenseCountRecordTypeLowerName[3:19]:  DispenseCountRecordTypeInstallSignIpa,
	_DispenseCountRecordTypeName[19:34]:      DispenseCountRecordTypeAdminPresented,
	_DispenseCountRecordTypeLowerName[19:34]: DispenseCountRecordTypeAdminPresented,
	_DispenseCountRecordTypeName[34:47]:      DispenseCountRecordTypeAdminDeleted,
	_DispenseCountRecordTypeLowerName[34:47]: DispenseCountRecordTypeAdminDeleted,
}

var _DispenseCountRecordTypeNames = []string{
	_DispenseCountRecordTypeName[0:3],
	_DispenseCountRecordTypeName[3:19],
	_DispenseCountRecordTypeName[19:34],
	_DispenseCountRecordTypeName[34:47],
}

// DispenseCountRecordTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DispenseCountRecordTypeString(s string) (DispenseCountRecordType, error) {
	if val, ok := _DispenseCountRecordTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DispenseCountRecordTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to DispenseCountRecordType values", s)
}

// DispenseCountRecordTypeValues returns all values of the enum
func DispenseCountRecordTypeValues() []DispenseCountRecordType {
	return _DispenseCountRecordTypeValues
}

// DispenseCountRecordTypeStrings returns a slice of all String values of the enum
func DispenseCountRecordTypeStrings() []string {
	strs := make([]string, len(_DispenseCountRecordTypeNames))
	copy(strs, _DispenseCountRecordTypeNames)
	return strs
}

// IsADispenseCountRecordType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i DispenseCountRecordType) IsADispenseCountRecordType() bool {
	for _, v := range _DispenseCountRecordTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for DispenseCountRecordType
func (i DispenseCountRecordType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for DispenseCountRecordType
func (i *DispenseCountRecordType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("DispenseCountRecordType should be a string, got %s", data)
	}

	var err error
	*i, err = DispenseCountRecordTypeString(s)
	return err
}

func (i DispenseCountRecordType) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *DispenseCountRecordType) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of DispenseCountRecordType: %[1]T(%[1]v)", value)
	}

	val, err := DispenseCountRecordTypeString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}
